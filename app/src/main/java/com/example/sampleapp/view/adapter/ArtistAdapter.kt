package com.example.sampleapp.view.adapterimport android.content.Contextimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.Filterimport android.widget.Filterableimport android.widget.Toastimport androidx.recyclerview.widget.RecyclerViewimport com.example.sampleapp.Appimport com.example.sampleapp.databinding.ItemLayoutBindingimport com.example.sampleapp.extensions.hideimport com.example.sampleapp.extensions.showimport com.example.sampleapp.model.Artistimport com.example.sampleapp.model.FavoriteArtistimport com.example.sampleapp.repository.ArtistRepositoryimport com.example.sampleapp.repository.FavoriteRepositoryimport com.example.sampleapp.util.Messagesimport java.util.*import javax.inject.Injectclass ArtistAdapter(        private val context: Context,        internal var list: MutableList<Artist>) : RecyclerView.Adapter<ArtistAdapter.ViewHolder>(), Filterable {    private lateinit var binding: ItemLayoutBinding    val originalList = list    @Inject    lateinit var artistRepository: ArtistRepository    @Inject    lateinit var favoriteRepository: FavoriteRepository    init {        setHasStableIds(true)    }    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {        val appComponent = App.appComponent        appComponent.inject(this)        binding = ItemLayoutBinding                .inflate(LayoutInflater.from(parent.context), parent, false)        return ViewHolder(binding, artistRepository)    }    override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val artist = list[position]        holder.apply {            bind(createOnClickListener(artist), artist)            itemView.tag = position        }    }    fun updateList(artists: List<Artist>) {        list.clear()        list.addAll(artists)        notifyDataSetChanged()    }    private fun createOnClickListener(artist: Artist): View.OnClickListener {        return View.OnClickListener {            when {                !artistRepository.getArtistFavorite(artist.id) -> insertFavorite(artist)                else -> removeFavorite(artist)            }            notifyDataSetChanged()        }    }    private fun insertFavorite(artist: Artist) {        artist.favorite = true        artistRepository.setArtistFavorite(artist)        val artistFavorite = getFavoriteArtist(artist)        val favorite = mutableListOf<FavoriteArtist>()        favorite.add(artistFavorite)        favoriteRepository.insertFavorite(favorite)        Toast.makeText(context, Messages.addedArtist, Toast.LENGTH_SHORT).show()    }    private fun removeFavorite(artist: Artist) {        artist.favorite = false        artistRepository.setArtistFavorite(artist)        favoriteRepository.removeFavorite(artist.id)        Toast.makeText(context, Messages.removedArtist, Toast.LENGTH_SHORT).show()    }    private fun getFavoriteArtist(artist: Artist) =            FavoriteArtist(                    artist.id,                    artist.name,                    artist.poster,                    artist.favorite            )    override fun getItemId(position: Int): Long {        return list[position].id.toLong()    }    override fun getItemViewType(position: Int): Int {        return list[position].id    }    override fun getItemCount() = list.size    class ViewHolder(            private val binding: ItemLayoutBinding,            private val artistRepository: ArtistRepository    ) : RecyclerView.ViewHolder(binding.root) {        fun bind(listener: View.OnClickListener, item: Artist) {            binding.apply {                click = listener                artist = item            }            statusFavorite(item)        }        private fun statusFavorite(item: Artist) {            when {                artistRepository.getArtistFavorite(item.id) -> binding.ivFavote.show()                else -> binding.ivFavote.hide()            }        }    }    @Suppress("UseExpressionBody")    override fun getFilter(): Filter {        return object : Filter() {            override fun performFiltering(constraint: CharSequence?): FilterResults {                val results = FilterResults()                with(results) {                    if (constraint!!.isEmpty()) {                        values = list                        count = list.size                    } else {                        val filterList = ArrayList<Artist>()                        for (item in list) {                            if (item.name.toUpperCase(Locale.getDefault())                                            .startsWith(constraint.toString()                                                    .toUpperCase(Locale.getDefault())))                                filterList.add(item)                        }                        values = filterList                        count = list.size                    }                }                return results            }            override fun publishResults(constraint: CharSequence?, results: FilterResults?) {                if (results?.count == 0 || constraint == "") {                    list = originalList                    notifyDataSetChanged()                } else {                    list = results?.values as MutableList<Artist>                    notifyDataSetChanged()                }            }        }    }}